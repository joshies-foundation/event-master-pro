import { inject, Injectable } from '@angular/core';
import { PostgrestSingleResponse, SupabaseClient } from '@supabase/supabase-js';
import { Database, Tables } from '../util/schema';
import {
  BetModel,
  OmitAutoGeneratedColumns,
  PlayerModel,
} from '../util/supabase-types';
import {
  BetStatus,
  Function,
  realtimeUpdatesFromTable,
  Table,
} from '../util/supabase-helpers';
import {
  combineLatest,
  map,
  Observable,
  of,
  shareReplay,
  switchMap,
} from 'rxjs';
import { GameStateService } from './game-state.service';
import { PlayerService, PlayerWithUserInfo } from './player.service';
import { whenAllValuesNotNull, whenNotNull } from '../util/rxjs-helpers';
import { toSignal } from '@angular/core/rxjs-interop';
import { ChartData } from 'chart.js';
import { getCssVariableValue } from '../util/css-helpers';
import { betGainOrLossAmount, betIsResolved } from '../util/bet-helpers';

@Injectable({
  providedIn: 'root',
})
export class BetService {
  private readonly supabase: SupabaseClient<Database> = inject(SupabaseClient);
  private readonly gameStateService = inject(GameStateService);
  private readonly playerService = inject(PlayerService);

  readonly bets$: Observable<BetModel[] | null> =
    // get user player id
    combineLatest({
      players: this.playerService.playersIncludingDisabled$,
      userPlayerId: this.playerService.userPlayerId$,
    }).pipe(
      switchMap(({ players, userPlayerId }) => {
        if (!players || !userPlayerId) return of(null);

        // get both requester bets and opponent bets
        return combineLatest({
          requesterBets: realtimeUpdatesFromTable(
            this.supabase,
            Table.Bet,
            `requester_player_id=eq.${userPlayerId}`,
          ),
          opponentBets: realtimeUpdatesFromTable(
            this.supabase,
            Table.Bet,
            `opponent_player_id=eq.${userPlayerId}`,
          ),
        }).pipe(
          map(({ requesterBets, opponentBets }) =>
            requesterBets
              // concatenate the 2 together
              .concat(opponentBets)
              // sort by date, descending (newest first)
              .sort(
                (a, b) =>
                  new Date(b.updated_at).getTime() -
                  new Date(a.updated_at).getTime(),
              ),
          ),
          map((bets) => linkPlayersToBets(bets, players)),
        );
      }),
      shareReplay(1),
    );

  readonly bets = toSignal(this.bets$);

  readonly betRequests$ = combineLatest({
    bets: this.bets$,
    userPlayerId: this.playerService.userPlayerId$,
  }).pipe(
    whenAllValuesNotNull(({ bets, userPlayerId }) =>
      of(
        [...bets]
          .filter(
            (bet) =>
              bet.status === BetStatus.PendingAcceptance &&
              userPlayerId === bet.opponent_player_id,
          )
          // sort by date, ascending (oldest first)
          .sort(
            (a, b) =>
              new Date(a.created_at).getTime() -
              new Date(b.created_at).getTime(),
          ),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly betsAwaitingAcceptance$ = combineLatest({
    bets: this.bets$,
    userPlayerId: this.playerService.userPlayerId$,
  }).pipe(
    whenAllValuesNotNull(({ bets, userPlayerId }) =>
      of(
        [...bets]
          .filter(
            (bet) =>
              bet.status === BetStatus.PendingAcceptance &&
              userPlayerId === bet.requester_player_id,
          )
          // sort by date, ascending (oldest first)
          .sort(
            (a, b) =>
              new Date(a.created_at).getTime() -
              new Date(b.created_at).getTime(),
          ),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly numBetRequests$ = this.betRequests$.pipe(
    map((betRequests) => betRequests?.length ?? 0),
  );

  readonly numBetRequests = toSignal(this.numBetRequests$, {
    initialValue: 0,
  });

  readonly resolvedBets$ = this.bets$.pipe(
    whenNotNull((bets) => of(bets.filter((bet) => betIsResolved(bet.status)))),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly nonPushResolvedBets$ = this.bets$.pipe(
    whenNotNull((bets) =>
      of(
        bets.filter(
          (bet) => betIsResolved(bet.status) && bet.status !== BetStatus.Push,
        ),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly numResolvedBets$ = this.resolvedBets$.pipe(
    whenNotNull((resolvedBets) => of(resolvedBets.length)),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly activeBets$ = this.bets$.pipe(
    whenNotNull((bets) =>
      of([...bets].filter((bet) => bet.status === BetStatus.Active).reverse()),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly numActiveBets$ = this.activeBets$.pipe(
    whenNotNull((activeBets) => of(activeBets.length)),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly overallWinPercentage$ = combineLatest({
    resolvedBets: this.nonPushResolvedBets$,
    userPlayerId: this.playerService.userPlayerId$,
  }).pipe(
    whenAllValuesNotNull(({ resolvedBets, userPlayerId }) =>
      of(
        resolvedBets.length === 0
          ? 0
          : (resolvedBets.reduce((prev, bet) => {
              const userWon =
                (bet.status === BetStatus.RequesterWon &&
                  bet.requester_player_id === userPlayerId) ||
                (bet.status === BetStatus.OpponentWon &&
                  bet.opponent_player_id === userPlayerId);

              return prev + (userWon ? 1 : 0);
            }, 0) /
              resolvedBets.length) *
              100,
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly betSummaryChartData$: Observable<ChartData | null> = combineLatest({
    userPlayerId: this.playerService.userPlayerId$,
    bets: this.resolvedBets$.pipe(
      map((bets) => (bets ? [...bets].reverse() : bets)),
    ),
  }).pipe(
    whenAllValuesNotNull(
      ({ userPlayerId, bets }): Observable<ChartData> =>
        of({
          labels: Array.from({ length: bets.length }, () => ''),
          datasets: [
            {
              label: 'Total Profit',
              data: bets.reduce<number[]>(
                (prev, bet, index) => [
                  ...prev,
                  (prev[index - 1] ?? 0) +
                    betGainOrLossAmount(bet, userPlayerId),
                ],
                [],
              ),
              borderColor: getCssVariableValue('--color-foreground'),
              borderWidth: 2,
              type: 'line',
            },
            {
              label: 'Bet Result',
              data:
                bets.map((bet) => betGainOrLossAmount(bet, userPlayerId)) ?? [],
              backgroundColor:
                bets.map((bet) =>
                  betGainOrLossAmount(bet, userPlayerId) > 0
                    ? getCssVariableValue(
                        '--color-success-background-translucent',
                      )
                    : getCssVariableValue(
                        '--color-danger-background-translucent',
                      ),
                ) ?? [],
              borderColor:
                bets.map((bet) =>
                  betGainOrLossAmount(bet, userPlayerId) > 0
                    ? getCssVariableValue('--color-success-foreground')
                    : getCssVariableValue('--color-danger-foreground'),
                ) ?? [],
              borderWidth: 1,
              borderRadius: 20,
              maxBarThickness: 12,
            },
          ],
        } as ChartData),
    ),
    shareReplay(1),
  );

  readonly betSummaryChartData = toSignal(this.betSummaryChartData$);

  readonly totalProfit$ = combineLatest({
    bets: this.resolvedBets$,
    userPlayerId: this.playerService.userPlayerId$,
  }).pipe(
    whenAllValuesNotNull(({ bets, userPlayerId }) =>
      of(
        bets.reduce(
          (prev, bet) => prev + betGainOrLossAmount(bet, userPlayerId),
          0,
        ),
      ),
    ),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly allBetsForThisSession$: Observable<BetModel[] | null> =
    combineLatest({
      sessionId: this.gameStateService.sessionId$,
      players: this.playerService.playersIncludingDisabled$,
    }).pipe(
      whenAllValuesNotNull(({ sessionId, players }) =>
        realtimeUpdatesFromTable(
          this.supabase,
          Table.Bet,
          `session_id=eq.${sessionId}`,
        ).pipe(
          map((bets) =>
            bets
              // sort by date
              .sort(
                (a, b) =>
                  new Date(b.created_at).getTime() -
                  new Date(a.created_at).getTime(),
              ),
          ),
          map((bets) => linkPlayersToBets(bets, players)),
        ),
      ),
      shareReplay({ bufferSize: 1, refCount: true }),
    );

  async createBet(
    bet: OmitAutoGeneratedColumns<Tables<Table.Bet>>,
  ): Promise<PostgrestSingleResponse<null>> {
    return this.supabase.from(Table.Bet).insert(bet);
  }

  async acceptBet(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetAccepted, { bet_id: id });
  }

  async pushBet(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetPush, { bet_id: id });
  }

  async submitBetRequesterWon(
    id: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetRequesterWon, { bet_id: id });
  }

  async submitBetOpponentWon(
    id: number,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetOpponentWon, { bet_id: id });
  }

  async cancelBetByGM(id: number): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.SubmitBetCanceledByGm, { bet_id: id });
  }

  async rejectBet(id: number): Promise<PostgrestSingleResponse<BetModel[]>> {
    return this.supabase
      .from(Table.Bet)
      .update({ status: BetStatus.Rejected })
      .eq('id', id)
      .select();
  }

  async cancelBetByRequester(
    id: number,
  ): Promise<PostgrestSingleResponse<BetModel[]>> {
    return this.supabase
      .from(Table.Bet)
      .update({ status: BetStatus.CanceledByRequester })
      .eq('id', id)
      .select();
  }

  async bulkCancelBets(
    playerId: PlayerModel['id'],
    includeActive: boolean,
  ): Promise<PostgrestSingleResponse<undefined>> {
    return this.supabase.rpc(Function.BulkCancelBets, {
      player_id: playerId,
      includeactive: includeActive,
    });
  }
}

function linkPlayersToBets(
  bets: Tables<Table.Bet>[],
  players: PlayerWithUserInfo[],
): BetModel[] {
  return bets.map((bet) => {
    const requester = players.find(
      (player) => player.player_id === bet.requester_player_id,
    );
    const opponent = players.find(
      (player) => player.player_id === bet.opponent_player_id,
    );

    return {
      ...bet,
      requester,
      opponent,
      status: bet.status as BetStatus,
    };
  });
}
